#version 460
layout(local_size_x = 256) in;

struct Particle { vec3 position; };
layout(std430, binding=0) buffer ParticleBuffer { Particle particles[]; };
layout(std430, binding=3) buffer GridOffsetBuffer { ivec2 gridOffsets[]; };
layout(std430, binding=4) buffer NeighborBuffer { int neighbors[]; };

uniform ivec3 gridDim;
uniform float cellSize;
uniform float h;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    Particle p = particles[idx];
    
    // 计算当前所在网格
    ivec3 centerGrid = ivec3(floor(p.position / cellSize));
    
    // 遍历3x3x3相邻网格
    int neighborCount = 0;
    for(int dx = -1; dx <= 1; ++dx) {
        for(int dy = -1; dy <= 1; ++dy) {
            for(int dz = -1; dz <= 1; ++dz) {
                ivec3 neighborGrid = centerGrid + ivec3(dx, dy, dz);
                
                // 边界检查
                if(any(lessThan(neighborGrid, ivec3(0))) || 
                   any(greaterThanEqual(neighborGrid, gridDim))) continue;
                
                // 获取该网格的粒子列表
                int gridHash = neighborGrid.x + neighborGrid.y * gridDim.x 
                             + neighborGrid.z * gridDim.x * gridDim.y;
                ivec2 offset = gridOffsets[gridHash];
                
                // 遍历网格内粒子
                for(int i = 0; i < offset.y; ++i) {
                    int j = offset.x + i;
                    Particle q = particles[j];
                    float dist = distance(p.position, q.position);
                    
                    if(dist < h && j != idx) {
                        neighbors[idx * MAX_NEIGHBORS + neighborCount] = j;
                        neighborCount++;
                        if(neighborCount >= MAX_NEIGHBORS) break;
                    }
                }
            }
        }
    }
}